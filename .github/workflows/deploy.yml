# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Build & Deploy

#  event that fires every time a PR is created, synchronised with the source branch, (a new commit is pushed), or reopened.
# on: ["pull_request"]

# uses https://github.com/peter-evans/slash-command-dispatch chat-ops
# /deploy -> dispatches deploy-command
on:
  repository_dispatch:
    types: [deploy-command]

env:
  TERM: xterm-256color
  FORCE_COLOR: true
  BRANCH_NAME:  ${{ github.event.client_payload.pull_request.head.ref }}
  NX_BRANCH: ${{ github.event.client_payload.pull_request.head.ref }}
  NX_RUN_GROUP: ${{ github.run_id }}
  GCP_PROJECT_ID: core-314910

jobs:
  # cache all node_modules that are used in mono-repo apps
  build:
    name: Install dependencies
    runs-on: ubuntu-latest
    outputs:
      cache-hit: ${{ steps.cache.outputs.cache-hit }}
      affected: ${{ steps.affected.outputs.affected }}
    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ github.event.client_payload.pull_request.head.ref }}
          fetch-depth: 0

      - run: git fetch origin $BRANCH_NAME

      - name: Setup Node
        uses: actions/setup-node@v1
        with:
          node-version: 13.x

      - name: Hit cache for dependencies (if exists)
        id: cache
        uses: actions/cache@v2
        with:
          path: ./node_modules
          key: modules-${{ hashFiles('package-lock.json') }}

      - name: Install development dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: npm install --ignore-scripts

  # create the node docker image using cloud build, which pushes to cloud registry
  create_backend_image:
    needs: build
    name: Build backend image
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ github.event.client_payload.pull_request.head.ref }}

      - name: Add service account key for generate:xlf
        run: echo ${{ secrets.XLF_GCP_SA_KEY }} | base64 -d > translate.service_account.json

      - name: Get cached dependencies
        id: cache
        uses: actions/cache@v2
        with:
          path: ./node_modules
          key: modules-${{ hashFiles('package-lock.json') }}

      - name: Build backend dist
        env:
          GOOGLE_APPLICATION_CREDENTIALS: translate.service_account.json
        run: |
          npm run generate:xlf --project=backend
          npm run start backend:build:production

      - uses: StageUp/docker-cloud-build@1.0.3
        with:
          gcp-project-id: ${{ secrets.GCP_PROJECT_ID }}
          gcp-service-account-key: ${{ secrets.CLOUD_BUILD_GCP_SA_KEY }}
          gcp-gcr-region: eu.gcr.io
          image-tag-branch-latest: true
          image-sources: dist,apps/backend/Dockerfile
          image-tag-format: ft-$BRANCH-$SHA
          image-name: core-backend
          github-disabled: true

  # create the angular docker image using cloud build, which pushes to cloud registry
  create_frontend_image:
    needs: build
    name: Build frontend image
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ github.event.client_payload.pull_request.head.ref }}

      - name: Add service account key for generate:xlf
        run: echo ${{ secrets.XLF_GCP_SA_KEY }} | base64 -d > translate.service_account.json

      - name: Get cached dependencies
        id: cache
        uses: actions/cache@v2
        with:
          path: ./node_modules
          key: modules-${{ hashFiles('package-lock.json') }}

      - name: Build dist
        env:
          STRIPE_PUBLIC_KEY: ${{ secrets.STRIPE_PUBLIC_KEY }}
          LOAD_BALANCER_URL: https://${{ env.BRANCH_NAME }}.${{ secrets.LOAD_BALANCER_URL }}
          GOOGLE_APPLICATION_CREDENTIALS: translate.service_account.json
        run: |
          npm run generate:xlf --project=frontend
          npm run start frontend:build:production -- --is-deployed

      # move all nginx configurations into dist for Dockerfile to use
      - run: mv apps/frontend/nginx dist/apps/frontend

      - uses: StageUp/docker-cloud-build@1.0.3
        with:
          gcp-project-id: ${{ secrets.GCP_PROJECT_ID }}
          gcp-service-account-key: ${{ secrets.CLOUD_BUILD_GCP_SA_KEY }}
          gcp-gcr-region: eu.gcr.io
          image-tag-branch-latest: true
          image-sources: dist,apps/frontend/Dockerfile
          image-tag-format: ft-$BRANCH-$SHA
          image-name: core-frontend
          github-token: ${{ secrets.GITHUB_TOKEN }}

  # deploy the new infrastructure once both images built
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [create_frontend_image, create_backend_image]
    if: |
      always() &&
      (needs.create_frontend_image.result == 'success' || needs.create_frontend_image.result == 'skipped') &&
      (needs.create_backend_image.result == 'success' || needs.create_backend_image.result == 'skipped')
    env:
      # for some reason workspace is "default" even when explicity selected
      TF_WORKSPACE: feat
    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ github.event.client_payload.pull_request.head.ref }}

      # have a service account on the file system to be used by the tf script
      # select existing workspace or make a new one in the case of first time run
      - name: Setup Terraform workspace
        # literal block scalar because these are separate commands
        run: |
          echo ${{ secrets.TF_GCP_SA_KEY }} | base64 -d > terraform/terraform.service_account.json
          terraform -chdir=terraform init
          terraform -chdir=terraform workspace select feat || terraform workspace new feat

      # infra a go-go
      - name: Create infrastructure
        # folded block scalar because this is one big long command
        run: >
          terraform -chdir=terraform apply
          -var 'workspace=feat'
          -var 'feat_suffix=${{ env.BRANCH_NAME }}'
          -var 'gcp_project_id=core-314910'
          -var 'sql_password=helloworld'
          -var 'stripe_api_token=${{ secrets.STRIPE_TEST_SECRET_KEY }}'
          -lock=false
          -auto-approve

      # setup the webhook fan-out for this deploy branch
      - uses: fjogeleit/http-request-action@master
        with:
          # forward it to nginx/api which will proxy the request to the backend
          url: "https://webhooks.stageup.uk/endpoints?url=https://${{ env.BRANCH_NAME }}.stageup.uk/api&api_key=${{ secrets.SU_WEBHOOKS_API_KEY }}"
          method: 'POST'
          ignoreStatusCodes: true # will fire this on every PR run
          timeout: 10000 # serverless cold starts can take a while

  # update /deploy message with update
  comment:
    name: Comment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() # run regardless of if deploy failed
    steps:
      - uses: haya14busa/action-cond@v1
        id: body
        with:
          cond: ${{ needs.deploy.result == 'success' }}
          if_true: "Deployed! [https://${{ env.BRANCH_NAME }}.stageup.uk/en](https://${{ env.BRANCH_NAME }}.stageup.uk/en) (${{ github.event.client_payload.pull_request.head.sha }}) :sparkles:"
          if_false: "Deployment failed, check job status for reason :whale:"

      - name: Update comment if exists
        if: steps.fc.outputs.comment-id != ''
        uses: peter-evans/create-or-update-comment@v1
        with:
          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}
          body: ${{ steps.body.outputs.value }}
